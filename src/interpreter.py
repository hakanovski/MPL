"""
src/interpreter.py
====================================
The Interpreter (The Ritual Performer).
Executes the Abstract Syntax Tree (AST) generated by the Parser.
It manages memory (Environment), handles the Tesla Protocol, 
and executes the 13 Sealed Verbs.
"""

import time
from typing import Any, List, Dict, Optional
from .lexer import TokenType, Token
from .parser import (
    Stmt, Expr, Block, Cycle, Conditional,
    Invoke, Bind, Summon, Circle, Seal, Omen, Hex, Morph, Pact, Banish, Purge, Abyss, Echo,
    Literal, Variable, Binary, Param
)

class RuntimeException(Exception):
    """Raised when a ritual fails during execution."""
    pass

class Environment:
    """
    The Memory of the System. 
    Stores variables (Bindings) and handles Scopes.
    """
    def __init__(self, enclosing=None):
        self.values: Dict[str, Any] = {}
        self.enclosing = enclosing  # For parent scopes (like inside a loop)
        self.sealed: List[str] = [] # List of sealed (immutable) variables

    def define(self, name: str, value: Any):
        if name in self.sealed:
            raise RuntimeException(f"Cannot re-bind sealed variable '{name}'.")
        self.values[name] = value

    def get(self, name: Token) -> Any:
        if name.lexeme in self.values:
            return self.values[name.lexeme]
        
        if self.enclosing:
            return self.enclosing.get(name)

        raise RuntimeException(f"Undefined variable '{name.lexeme}'.")

    def assign(self, name: Token, value: Any):
        if name.lexeme in self.sealed:
            raise RuntimeException(f"Cannot hex/modify sealed variable '{name.lexeme}'.")
            
        if name.lexeme in self.values:
            self.values[name.lexeme] = value
            return

        if self.enclosing:
            self.enclosing.assign(name, value)
            return

        raise RuntimeException(f"Undefined variable '{name.lexeme}'.")

    def seal(self, name: str):
        if name in self.values:
            self.sealed.append(name)
        else:
            raise RuntimeException(f"Cannot seal undefined variable '{name}'.")

    def banish(self, name: str):
        if name in self.values:
            del self.values[name]
        elif self.enclosing:
            self.enclosing.banish(name)
        else:
            # Silent fail or error? For banish, silent is often preferred.
            pass

    def purge(self):
        self.values.clear()

class Interpreter:
    def __init__(self):
        self.environment = Environment()
        # We will load the Ontology (Magi Data) here in the future
        self.ontology = {} 

    def interpret(self, statements: List[Stmt]):
        try:
            for statement in statements:
                self.execute(statement)
        except RuntimeException as e:
            print(f"ðŸ’¥ Ritual Failure: {e}")

    def execute(self, stmt: Stmt):
        """
        The Dispatcher. Routes the statement to the correct handler.
        Using Python 3.10+ Pattern Matching would be cleaner, 
        but using if/elif for broad compatibility if needed. 
        (Here assuming Python 3.10+ features are available or using isinstance).
        """
        # --- 13 Sealed Verbs ---
        if isinstance(stmt, Echo):
            value = self.evaluate(stmt.message)
            print(f"ðŸ‘ï¸â€ðŸ—¨ï¸ [ECHO]: {value}")
        
        elif isinstance(stmt, Bind):
            value = self.evaluate(stmt.value)
            self.environment.define(stmt.name, value)
            
        elif isinstance(stmt, Omen):
            # Reads input from the user
            val = input(f"ðŸ”® [OMEN] Enter value for '{stmt.target}': ")
            self.environment.define(stmt.target, val)

        elif isinstance(stmt, Circle):
            # Error Handling Block
            try:
                self.execute(stmt.body)
            except Exception as e:
                print(f"ðŸ›¡ï¸ [CIRCLE] Protected against chaos: {e}")

        elif isinstance(stmt, Seal):
            self.environment.seal(stmt.target)
            print(f"ðŸ”’ [SEAL] Variable '{stmt.target}' is now immutable.")

        elif isinstance(stmt, Hex):
            # Hex is a complex manipulation. For v0.1, we treat it as assignment/modification.
            # hex target with param=value
            # Simplified: Assuming one param 'value' for update
            val = None
            for p in stmt.params:
                if p.name == "val" or p.name == "value":
                    val = self.evaluate(p.value)
            
            if val is not None:
                # We need a Token object for the assign method, 
                # creating a dummy one for now or changing env logic.
                # Quick fix: create a dummy token structure
                dummy_token = Token(TokenType.IDENTIFIER, stmt.target, None, 0)
                self.environment.assign(dummy_token, val)
            else:
                 print(f"âš ï¸ [HEX] No 'value' parameter provided to hex '{stmt.target}'.")

        elif isinstance(stmt, Banish):
            self.environment.banish(stmt.target)
            print(f"ðŸ—‘ï¸ [BANISH] '{stmt.target}' cast into the void.")

        elif isinstance(stmt, Purge):
            self.environment.purge()
            print("ðŸ”¥ [PURGE] Memory cleansed.")

        elif isinstance(stmt, Abyss):
            msg = self.evaluate(stmt.message)
            raise RuntimeException(msg)

        elif isinstance(stmt, Cycle):
            self._execute_cycle(stmt)

        elif isinstance(stmt, Morph):
            self._execute_morph(stmt)

        elif isinstance(stmt, Block):
            self.execute_block(stmt.statements, Environment(self.environment))

        elif isinstance(stmt, Conditional):
            if self._is_truthy(self.evaluate(stmt.condition)):
                self.execute(stmt.then_branch)
            elif stmt.else_branch:
                self.execute(stmt.else_branch)

    def _execute_cycle(self, stmt: Cycle):
        count = self.evaluate(stmt.frequency)
        if not isinstance(count, int):
            raise RuntimeException("Cycle frequency must be an integer.")
        
        # --- THE TESLA PROTOCOL (3-6-9) ---
        is_resonant = count in [3, 6, 9]
        
        if is_resonant:
            print(f"âš¡ [TESLA PROTOCOL] Resonant Frequency {count} detected. Optimizing ritual...")
            # In a real engine, we would increase thread priority here.
            time.sleep(0.1) # Simulating "gathering energy"
            
        for i in range(count):
            self.execute(stmt.body)

    def _execute_morph(self, stmt: Morph):
        # transmutes variable to another type
        # Fetch current value
        dummy_token = Token(TokenType.IDENTIFIER, stmt.target, None, 0)
        current_val = self.environment.get(dummy_token)
        
        new_val = current_val
        try:
            if stmt.target_type == TokenType.TYPE_MANA: # Int
                new_val = int(current_val)
            elif stmt.target_type == TokenType.TYPE_FLUX: # Float
                new_val = float(current_val)
            elif stmt.target_type == TokenType.TYPE_SIGIL: # String
                new_val = str(current_val)
            
            self.environment.assign(dummy_token, new_val)
            print(f"âš—ï¸ [MORPH] '{stmt.target}' transmuted to {stmt.target_type.name}.")
            
        except ValueError:
            raise RuntimeException(f"Failed to morph '{stmt.target}'. Incompatible essence.")

    def execute_block(self, statements: List[Stmt], environment: Environment):
        previous = self.environment
        try:
            self.environment = environment
            for statement in statements:
                self.execute(statement)
        finally:
            self.environment = previous

    # --- Expression Evaluation ---

    def evaluate(self, expr: Expr) -> Any:
        if isinstance(expr, Literal):
            return expr.value
        if isinstance(expr, Variable):
            return self.environment.get(expr.name)
        if isinstance(expr, Binary):
            left = self.evaluate(expr.left)
            right = self.evaluate(expr.right)
            
            if expr.operator.type == TokenType.EQ: return left == right
            if expr.operator.type == TokenType.NEQ: return left != right
            if expr.operator.type == TokenType.GT: return left > right
            if expr.operator.type == TokenType.LT: return left < right
            # Add arithmetic here (+, -, *, /) for v0.2
            
        return None

    def _is_truthy(self, object: Any) -> bool:
        if object is None: return False
        if isinstance(object, bool): return object
        return True
