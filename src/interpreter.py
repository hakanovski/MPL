"""
src/interpreter.py
====================================
The Interpreter (The Ritual Performer).
Executes the Abstract Syntax Tree (AST) generated by the Parser.
It manages memory (Environment), handles the Tesla Protocol,
and executes the 13 Sealed Verbs.
"""

import time
from typing import Any, List, Dict, Optional
from .lexer import TokenType, Token
from .parser import (
    Stmt, Expr, Block, Cycle, Conditional,
    Invoke, Bind, Summon, Circle, Seal, Omen, Hex, Morph, Pact, Banish, Purge, Abyss, Echo,
    Literal, Variable, Binary, Param
)
# Integration with the Standard Library
from .stdlib import StdLib

class RuntimeException(Exception):
    """Raised when a ritual fails during execution."""
    pass

class Environment:
    """
    The Memory of the System.
    Stores variables (Bindings) and handles Scopes.
    """
    def __init__(self, enclosing=None):
        self.values: Dict[str, Any] = {}
        self.enclosing = enclosing  # For parent scopes (like inside a loop)
        self.sealed: List[str] = [] # List of sealed (immutable) variables

    def define(self, name: str, value: Any):
        if name in self.sealed:
            raise RuntimeException(f"Cannot re-bind sealed variable '{name}'.")
        self.values[name] = value

    def get(self, name: Token) -> Any:
        if name.lexeme in self.values:
            return self.values[name.lexeme]

        if self.enclosing:
            return self.enclosing.get(name)

        raise RuntimeException(f"Undefined variable '{name.lexeme}'.")

    def assign(self, name: Token, value: Any):
        if name.lexeme in self.sealed:
            raise RuntimeException(f"Cannot hex/modify sealed variable '{name.lexeme}'.")

        if name.lexeme in self.values:
            self.values[name.lexeme] = value
            return

        if self.enclosing:
            self.enclosing.assign(name, value)
            return

        raise RuntimeException(f"Undefined variable '{name.lexeme}'.")

    def seal(self, name: str):
        if name in self.values:
            self.sealed.append(name)
        else:
            raise RuntimeException(f"Cannot seal undefined variable '{name}'.")

    def banish(self, name: str):
        if name in self.values:
            del self.values[name]
        elif self.enclosing:
            self.enclosing.banish(name)
        else:
            pass # Silent banish

    def purge(self):
        self.values.clear()

class Interpreter:
    def __init__(self):
        self.environment = Environment()
        # The Resolver (Ontology) will be injected from main.py or mpl_shell.py
        self.resolver = None

    def interpret(self, statements: List[Stmt]):
        try:
            for statement in statements:
                self.execute(statement)
        except RuntimeException as e:
            print(f"ðŸ’¥ Ritual Failure: {e}")

    def execute(self, stmt: Stmt):
        """
        The Dispatcher. Routes the statement to the correct handler.
        """
        # --- 13 Sealed Verbs ---
        if isinstance(stmt, Echo):
            value = self.evaluate(stmt.message)
            print(f"ðŸ‘ï¸â€ðŸ—¨ï¸ [ECHO]: {value}")

        elif isinstance(stmt, Bind):
            value = self.evaluate(stmt.value)
            self.environment.define(stmt.name, value)

        elif isinstance(stmt, Invoke):
            self._execute_invoke(stmt)

        elif isinstance(stmt, Omen):
            # Reads input from the user
            val = input(f"ðŸ”® [OMEN] Enter value for '{stmt.target}': ")
            self.environment.define(stmt.target, val)

        elif isinstance(stmt, Circle):
            # Error Handling Block (Try/Catch)
            try:
                self.execute(stmt.body)
            except Exception as e:
                print(f"ðŸ›¡ï¸ [CIRCLE] Protected against chaos: {e}")

        elif isinstance(stmt, Seal):
            self.environment.seal(stmt.target)
            print(f"ðŸ”’ [SEAL] Variable '{stmt.target}' is now immutable.")

        elif isinstance(stmt, Hex):
            # hex target with val=newValue
            val = None
            for p in stmt.params:
                if p.name in ["val", "value"]:
                    val = self.evaluate(p.value)

            if val is not None:
                # Create a temporary token for assignment lookup
                dummy_token = Token(TokenType.IDENTIFIER, stmt.target, None, 0)
                self.environment.assign(dummy_token, val)
            else:
                 print(f"âš ï¸ [HEX] No 'value' parameter provided to hex '{stmt.target}'.")

        elif isinstance(stmt, Banish):
            self.environment.banish(stmt.target)
            print(f"ðŸ—‘ï¸ [BANISH] '{stmt.target}' cast into the void.")

        elif isinstance(stmt, Purge):
            self.environment.purge()
            print("ðŸ”¥ [PURGE] Memory cleansed.")

        elif isinstance(stmt, Abyss):
            msg = self.evaluate(stmt.message)
            raise RuntimeException(msg)

        elif isinstance(stmt, Cycle):
            self._execute_cycle(stmt)

        elif isinstance(stmt, Morph):
            self._execute_morph(stmt)

        # --- Structural ---
        elif isinstance(stmt, Block):
            self.execute_block(stmt.statements, Environment(self.environment))

        elif isinstance(stmt, Conditional):
            if self._is_truthy(self.evaluate(stmt.condition)):
                self.execute(stmt.then_branch)
            elif stmt.else_branch:
                self.execute(stmt.else_branch)

    # --- Specific Execution Logic ---

    def _execute_invoke(self, stmt: Invoke):
        """
        Handles the INVOKE command.
        1. Checks Ontology (Resolver) for the entity.
        2. Injects Entity attributes into scope.
        3. Triggers mapped Standard Library functions (Technomancy).
        """
        entity_id = stmt.entity
        
        # Evaluate parameters (e.g., intent="heal")
        params = {}
        if stmt.params:
            for p in stmt.params:
                params[p.name] = self.evaluate(p.value)

        # 1. Query Ontology
        entity_data = None
        if self.resolver:
            entity_data = self.resolver.resolve(entity_id)

        if entity_data:
            print(f"ðŸ•¯ï¸ [INVOKE] Summoning {entity_data.get('name', entity_id)}...")
            
            # 2. Check for Technomancy Mapping (JSON 'mpl_function')
            # Example: Bael -> "process.hide"
            magic_func = entity_data.get('mpl_function')
            if magic_func:
                # Execute the mapped Python function from StdLib
                # We pass the collected params as a list of values
                StdLib.call(magic_func.split('.')[0], magic_func.split('.')[1], list(params.values()))
            
            # Optional: Inject specific attributes if needed
            # role = entity_data.get('role')
            # print(f"   > Role: {role}")

        else:
            # If not in Ontology, try calling StdLib directly (e.g. invoke.tesla.oscillate)
            # This allows invoking modules that are not "Beings" in the JSON
            # Logic: entity_id might be "tesla" or "divination"
            print(f"âš ï¸ [INVOKE] The spirit '{entity_id}' did not answer (Not found in Grimoire).")

    def _execute_cycle(self, stmt: Cycle):
        count = self.evaluate(stmt.frequency)
        if not isinstance(count, int):
            raise RuntimeException("Cycle frequency must be an integer.")

        # --- THE TESLA PROTOCOL (3-6-9) ---
        is_resonant = count in [3, 6, 9]

        if is_resonant:
            print(f"âš¡ [TESLA PROTOCOL] Resonant Frequency {count} detected. Optimizing ritual...")
            time.sleep(0.1) # Simulating energy gathering

        for i in range(count):
            self.execute(stmt.body)

    def _execute_morph(self, stmt: Morph):
        # Transmutes variable to another type
        dummy_token = Token(TokenType.IDENTIFIER, stmt.target, None, 0)
        current_val = self.environment.get(dummy_token)

        new_val = current_val
        try:
            if stmt.target_type == TokenType.TYPE_MANA: # Int
                new_val = int(current_val)
            elif stmt.target_type == TokenType.TYPE_FLUX: # Float
                new_val = float(current_val)
            elif stmt.target_type == TokenType.TYPE_SIGIL: # String
                new_val = str(current_val)
            
            self.environment.assign(dummy_token, new_val)
            # print(f"âš—ï¸ [MORPH] '{stmt.target}' transmuted.")

        except ValueError:
            raise RuntimeException(f"Failed to morph '{stmt.target}'. Incompatible essence.")

    def execute_block(self, statements: List[Stmt], environment: Environment):
        previous = self.environment
        try:
            self.environment = environment
            for statement in statements:
                self.execute(statement)
        finally:
            self.environment = previous

    # --- Expression Evaluation (Updated for Arithmetic) ---

    def evaluate(self, expr: Expr) -> Any:
        if isinstance(expr, Literal):
            return expr.value
        if isinstance(expr, Variable):
            return self.environment.get(expr.name)
        if isinstance(expr, Binary):
            left = self.evaluate(expr.left)
            right = self.evaluate(expr.right)
            op = expr.operator.type

            # --- Arithmetic Operations ---
            if op == TokenType.PLUS:
                # Handle String Concatenation
                if isinstance(left, str) or isinstance(right, str):
                    return str(left) + str(right)
                return left + right
            if op == TokenType.MINUS: return left - right
            if op == TokenType.STAR: return left * right
            if op == TokenType.SLASH: return left / right

            # --- Comparison Operations ---
            if op == TokenType.EQ: return left == right
            if op == TokenType.NEQ: return left != right
            if op == TokenType.GT: return left > right
            if op == TokenType.LT: return left < right
            if op == TokenType.GTE: return left >= right
            if op == TokenType.LTE: return left <= right

        return None

    def _is_truthy(self, object: Any) -> bool:
        if object is None: return False
        if isinstance(object, bool): return object
        if object == 0: return False
        if object == "": return False
        return True
