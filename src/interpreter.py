"""
src/interpreter.py
====================================
The Interpreter (The Ritual Performer).
Executes the Abstract Syntax Tree (AST) generated by the Parser.
It manages memory (Environment), handles the Tesla Protocol,
and executes the 13 Sealed Verbs.
"""

import time
from typing import Any, List, Dict, Optional
from .lexer import TokenType, Token
from .parser import (
    Stmt, Expr, Block, Cycle, Conditional,
    Invoke, Bind, Summon, Circle, Seal, Omen, Hex, Morph, Pact, Banish, Purge, Abyss, Echo,
    Literal, Variable, Binary, Param
)
# Integration with the Standard Library
from .stdlib import StdLib

class RuntimeException(Exception):
    """Raised when a ritual fails during execution."""
    pass

class Environment:
    """
    The Memory of the System.
    Stores variables (Bindings) and handles Scopes.
    """
    def __init__(self, enclosing=None):
        self.values: Dict[str, Any] = {}
        self.enclosing = enclosing  # For parent scopes (like inside a loop)
        self.sealed: List[str] = [] # List of sealed (immutable) variables

    def define(self, name: str, value: Any):
        if name in self.sealed:
            raise RuntimeException(f"Cannot re-bind sealed variable '{name}'.")
        self.values[name] = value

    def get(self, name: Token) -> Any:
        if name.lexeme in self.values:
            return self.values[name.lexeme]

        if self.enclosing:
            return self.enclosing.get(name)

        raise RuntimeException(f"Undefined variable '{name.lexeme}'.")

    def assign(self, name: Token, value: Any):
        if name.lexeme in self.sealed:
            raise RuntimeException(f"Cannot hex/modify sealed variable '{name.lexeme}'.")

        if name.lexeme in self.values:
            self.values[name.lexeme] = value
            return

        if self.enclosing:
            self.enclosing.assign(name, value)
            return

        raise RuntimeException(f"Undefined variable '{name.lexeme}'.")

    def seal(self, name: str):
        # 1. Check local scope
        if name in self.values:
            self.sealed.append(name)
            return
        
        # 2. Check outer scope (Recursive Fix)
        if self.enclosing:
            self.enclosing.seal(name)
            return

        # 3. Not found anywhere
        raise RuntimeException(f"Cannot seal undefined variable '{name}'.")

    def banish(self, name: str):
        if name in self.values:
            del self.values[name]
        elif self.enclosing:
            self.enclosing.banish(name)
        else:
            pass # Silent banish

    def purge(self):
        self.values.clear()

class Interpreter:
    def __init__(self):
        self.environment = Environment()
        self.resolver = None

    def interpret(self, statements: List[Stmt]):
        try:
            for statement in statements:
                self.execute(statement)
        except RuntimeException as e:
            print(f"ðŸ’¥ Ritual Failure: {e}")

    def execute(self, stmt: Stmt):
        """
        The Dispatcher. Routes the statement to the correct handler.
        """
        if isinstance(stmt, Echo):
            value = self.evaluate(stmt.message)
            print(f"ðŸ‘ï¸â€ðŸ—¨ï¸ [ECHO]: {value}")

        elif isinstance(stmt, Bind):
            value = self.evaluate(stmt.value)
            # Try to update existing variable first, else define new
            try:
                dummy_token = Token(TokenType.IDENTIFIER, stmt.name, None, 0)
                self.environment.assign(dummy_token, value)
            except RuntimeException:
                self.environment.define(stmt.name, value)

        elif isinstance(stmt, Invoke):
            self._execute_invoke(stmt)

        elif isinstance(stmt, Omen):
            val = input(f"ðŸ”® [OMEN] Enter value for '{stmt.target}': ")
            self.environment.define(stmt.target, val)

        elif isinstance(stmt, Circle):
            try:
                self.execute(stmt.body)
            except Exception as e:
                print(f"ðŸ›¡ï¸ [CIRCLE] Protected against chaos: {e}")

        elif isinstance(stmt, Seal):
            self.environment.seal(stmt.target)
            print(f"ðŸ”’ [SEAL] Variable '{stmt.target}' is now immutable.")

        elif isinstance(stmt, Hex):
            val = None
            for p in stmt.params:
                if p.name in ["val", "value"]:
                    val = self.evaluate(p.value)
            if val is not None:
                dummy_token = Token(TokenType.IDENTIFIER, stmt.target, None, 0)
                self.environment.assign(dummy_token, val)
            else:
                 print(f"âš ï¸ [HEX] No 'value' parameter provided to hex '{stmt.target}'.")

        elif isinstance(stmt, Banish):
            self.environment.banish(stmt.target)
            print(f"ðŸ—‘ï¸ [BANISH] '{stmt.target}' cast into the void.")

        elif isinstance(stmt, Purge):
            self.environment.purge()
            print("ðŸ”¥ [PURGE] Memory cleansed.")

        elif isinstance(stmt, Abyss):
            msg = self.evaluate(stmt.message)
            raise RuntimeException(msg)

        elif isinstance(stmt, Cycle):
            self._execute_cycle(stmt)

        elif isinstance(stmt, Morph):
            self._execute_morph(stmt)

        elif isinstance(stmt, Block):
            self.execute_block(stmt.statements, Environment(self.environment))

        elif isinstance(stmt, Conditional):
            if self._is_truthy(self.evaluate(stmt.condition)):
                self.execute(stmt.then_branch)
            elif stmt.else_branch:
                self.execute(stmt.else_branch)

    # --- Specific Execution Logic ---

    def _execute_invoke(self, stmt: Invoke):
        """
        Executes an invocation. It first checks the JSON Ontology (Resolver).
        If the entity is not in the JSON, it falls back to the Standard Library.
        """
        entity_id = stmt.entity
        params = {}
        if stmt.params:
            for p in stmt.params:
                params[p.name] = self.evaluate(p.value)
        
        args_list = list(params.values())

        # 1. Try to find the Entity in the JSON Database (Grimoire)
        entity_data = None
        if self.resolver:
            entity_data = self.resolver.resolve(entity_id)

        # SCENARIO A: Found in JSON (e.g., Historical figures)
        if entity_data:
            print(f"ðŸ•¯ï¸ [INVOKE] Summoning {entity_data.get('name', entity_id)}...")
            
            magic_func = entity_data.get('mpl_function')
            if magic_func:
                # Remove parentheses if present (e.g., "process.hide()")
                clean_func = magic_func.replace('()', '')
                
                if '.' in clean_func:
                    module_name = clean_func.split('.')[0]
                    func_name = clean_func.split('.')[1]
                    StdLib.call(module_name, func_name, args_list)
                else:
                     StdLib.call(clean_func, None, args_list)
            return

        # SCENARIO B: Not in JSON, Fallback to Standard Library directly
        # This handles cases like 'invoke.vassago' or 'market.divine' directly.
        
        # Clean the name (remove 'invoke.' prefix if parser included it)
        clean_name = entity_id.replace("invoke.", "")
        
        module_name = clean_name
        func_name = None

        if '.' in clean_name:
            parts = clean_name.split('.')
            module_name = parts[0]
            func_name = parts[1]

        # Call the Standard Library
        result = StdLib.call(module_name, func_name, args_list)
        
        # Note: StdLib.call handles printing error messages if the module is unknown.

    def _execute_cycle(self, stmt: Cycle):
        count = self.evaluate(stmt.frequency)
        if not isinstance(count, int):
            raise RuntimeException("Cycle frequency must be an integer.")

        is_resonant = count in [3, 6, 9]

        if is_resonant:
            print(f"âš¡ [TESLA PROTOCOL] Resonant Frequency {count} detected. Optimizing ritual...")
            time.sleep(0.1) 

        for i in range(count):
            self.execute(stmt.body)

    def _execute_morph(self, stmt: Morph):
        dummy_token = Token(TokenType.IDENTIFIER, stmt.target, None, 0)
        current_val = self.environment.get(dummy_token)

        try:
            if stmt.target_type == TokenType.TYPE_MANA: 
                new_val = int(current_val)
            elif stmt.target_type == TokenType.TYPE_FLUX: 
                new_val = float(current_val)
            elif stmt.target_type == TokenType.TYPE_SIGIL: 
                new_val = str(current_val)
            
            self.environment.assign(dummy_token, new_val)

        except ValueError:
            raise RuntimeException(f"Failed to morph '{stmt.target}'. Incompatible essence.")

    def execute_block(self, statements: List[Stmt], environment: Environment):
        previous = self.environment
        try:
            self.environment = environment
            for statement in statements:
                self.execute(statement)
        finally:
            self.environment = previous

    def evaluate(self, expr: Expr) -> Any:
        if isinstance(expr, Literal): return expr.value
        if isinstance(expr, Variable): return self.environment.get(expr.name)
        if isinstance(expr, Binary):
            left = self.evaluate(expr.left)
            right = self.evaluate(expr.right)
            op = expr.operator.type

            if op == TokenType.PLUS:
                if isinstance(left, str) or isinstance(right, str): return str(left) + str(right)
                return left + right
            if op == TokenType.MINUS: return left - right
            if op == TokenType.STAR: return left * right
            if op == TokenType.SLASH: return left / right

            if op == TokenType.EQ: return left == right
            if op == TokenType.NEQ: return left != right
            if op == TokenType.GT: return left > right
            if op == TokenType.LT: return left < right
            if op == TokenType.GTE: return left >= right
            if op == TokenType.LTE: return left <= right

        return None

    def _is_truthy(self, object: Any) -> bool:
        if object is None: return False
        if isinstance(object, bool): return object
        if object == 0: return False
        if object == "": return False
        return True
